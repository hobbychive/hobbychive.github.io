---
layout: post
title: GDSC(3) - Atomicity & Deadlock
date: 2023-05-20 15:51 +0900
categories: [GDSC]
tags: [gdsc yonsei, deadlock]
render_with_liquid: false
---

이 포스트에서는 **원자성**과 **교착상태**에 대해 설명하고, 이를 방지하거나 관리하는 방법에 대해 다룬다.

<br>

## atomic

<br>

원자성(atomicity)은 일반적으로 all-or-nothing을 의미한다. 데이터 트랜잭션이 모두 성공하거나 모두 실패하는 운용 집합니다. 항공 티켓 주문을 예시로 들면, 티켓은 지불과 예약이 동시에 되거나 둘 다 되지 않아야 한다. 지불이 되었는데 예약이 되지 않는 경우는 허용되지 않는다.

그러나 여러 프로세스가 동일한 자원에 접근하려는 것은 흔한 문제이다. 원자성을 확보하기 위해서는 각 프로세스가 자원에 접근 혹은 수정하는 순서를 정해야 하는데, 여러 프로세스 혹은 스레드들이 수행되는 시점을 조절하는 것을 `동기화(Synchronization)`라고 한다.

<br>

## Synchronization

<br>

하나의 자원에 동시 접근하려는 프로세스들을 동기화를 할 때, 각 프로세스가 해당 자원을 독점할 수 있도록 보장을 해주어야 하고 이를 `임계구역(critical section)`이라고 한다. 임계구역 동시 접근을 방지하는 방법, 즉 상호배제 방법은 여러가지가 있는데, 몇가지를 차례대로 살펴본다.

### lock

자원을 사용하고 있는 동안 다른 접근을 제한시키는 방식이다. 사용하기 전에 lock을 하고, 다 사용하고 나서 unlock을 하는 방식으로 사용 가능하다.

그러나 이 lock을 명시하는 변수 자체도 임계영역이 될 수 있으므로, lock이 풀림과 동시에 interrupt가 발생하면 동시 접근이 가능할 수 있다.

이를 해결하려면 다음과 같은 조건을 만족해야 한다:

1. 상호 배제의 보존 (Mutual exclusion)
2. 임계영역에 접근이 없을 때 항상 접근이 가능해야 함 (Progress)
3. 무한정 대기가 없어야 함 (Bounded waiting)

이 문제를 해결하기 위한 3가지 방식이 있는데,

1. 소프트웨어 알고리즘
2. 하드웨어 명령어로 구현
3. interrupt를 disable하고 enable

등이 있다.

<br>

## Software algorithms

<br>

### mutex

일종의 lock 매커니즘으로, lock을 가지고 있을 경우에만 공유 데이터에 접근 가능하다. 열쇠를 획득한 사람만 반납할 수 있다.

### Peterson's solution

자원을 사용하고 싶다는 flag를 보내고 turn 을 받아 접근하는 뮤텍스 알고리즘으로, 수도코드로 나타내면 다음과 같다:

```
do {
    flag[i] = true;
    turn = j;

    while (flag[j] && turn == j);   // busy waits

    --critical section

    flag[i] = false;

    --remainder section
} while (true);
```

5번 line에서 이전에 해당 자원을 쓰고 있는 프로세스가 종료될 때까지, spin lock 형태로 기다리며 이를 busy waits라고 한다.

두개의 프로세스에 대한 알고리즘이지면 현재는 일반화되어서 2개 이상의 프로세스 사이에서도 사용 가능하다.

### Semaphores

프로세스간의 시그널을 주고받기 위해 사용되는 정수값이며 다음 세가지 atomic 연산만을 지원한다:

1. initialize : 세마포어 초기화
2. decrement : 프로세스를 블록
3. increment : 블록되었던 프로세스를 깨움

이는 허용 가능한 카운터 개수를 의미하고, 이 중 0과 1의 값을 가지는 세마포어를 이진 세마포어라고 부르며 그 이상의 경우 counting semaphore 라고 한다.

### monitor

Mutex lock과 condition Variable(Queue)을 가지고 있는 매커니즘이다. lock 획득에 대한 순서를 queue에 저장한다. 공유 자원에 접근할 수 있는 키의 획득과 해제를 모두 처리해서 간단하다.

<br>

프로그램에서 스레드들이 동일한 포인트에 있는지 확인하여 동기화할 수 있고, 이 포인트 지점을 `배리어(Barrier)`라고 한다.

<br>

## Synchronization Hardware

<br>

소프트웨어적으로 race condition을 해결하는 것에는 명확한 한계점이 존재하므로 하드웨어에서 atomic 명령어를 지원한다. `test_and_set(TS)`와 `compare_and_swap(CAS)`라는 명령어이다. 이는 코드로 구현되어 있는 것이 아니라 하나의 명령어로 수행이 되게 되며, 하드웨어는 알아서 하나의 실행만을 하도록 허용한다.

### test_and_set

test_and_set은 lock의 값이 true인지 false인지 확인하고 그에 따른 bool 값을 리턴한다.

### compare_and_swap

TS의 확장된 형태로, lock의 현재 상태, 기대하는 값, lock을 바꿔줄 값을 인자로 받는다.

위 방식들은 Bounded waiting을 만족하지 못할 수 있다. lock이라는 변수를 여러 process가 얼마나 오랜 시간을 기다렸는지와 상관없이 경쟁적으로 lock을 가지려 하므로 while문이 끝나지 않을 수 있다. 이를 `라이브락(livelock)`이라고 한다.

<br>

## Deadlock

<br>

다른 프로세스가 진행되고 있는 라이브락과 달리, 프로세스들이 더이상 진행하지 못하고 영구적으로 블록이 되어있는 상태로, 결과적으로 아무것도 완료되지 못하는 상태를 의미한다. 교착상태는 다음과 같은 조건을 만족한다:

- 상호배제 (Mutual Exclusion) : 한 순간에 한 프로세스만이 자원을 사용할 수 있다. 즉, 한 프로세스에 의해 점유된 자원을 다른 프로세스들이 접근할 수 없다.

- 점유대기 (Hold and Wait) : 이미 자원을 보유한 프로세스가 다른 자원을 요청하며 기다리고 있다.

- 비선점 (No preemption) : 프로세스에 의해 점유된 자원을 다른 프로세스가 강제적으로 빼앗을 수 없다.

- 환형대기 (Circular Wait) : 프로세스간에 닫힌 연결이 존재할 경우이다. 블록된 프로세스가 자원을 점유하고 있는데 이 자원을 다른 프로세스가 원하며 대기하고 있는 상태이다.

<br>

## 동기화 문제

<br>

여러 프로세스를 어떻게 동기화할 것인가에 관한 고전적인 문제이다. 몇가지를 살펴본다.

### producer-consumer problem

유한한 개수의 물건을 임시로 보관하는 버퍼에 생산자와 소비자가 접근하는데, 생산자는 물건이 만들어지면 버퍼에 저장하고 소비자는 이를 사용한다. 이 때 저장할 공간이 없거나 가져올 물건이 없는 경우가 있을 수 있으며, **생산자-소비자 협동**을 통해 해결할 수 있다. 세마포어를 활용할 수 있다.

### readers-writers problem

독자는 데이터를 읽고 저자는 읽고 수정하는 프로세스이다. 독자는 프로세스 데이터 수정을 하지 않기 때문에, 모두 다 mutex 처리하는 것은 효율적이지 않다. reader들끼리 임계 구역에 들어가면 데이터 수정이 일어나지 않으므로 데이터 일관성이 유지된다. r/w를 따로 상호배타 시켜야 한다. 데이터베이스 직렬화를 생각하면 될 듯하다.

### dining philosophers problem

철학자 다섯이서 원형 식탁에 둘러앉아 밥을 먹는데, 각 철학자의 양쪽에 각각 젓가락이 한짝씩 놓여있으며 다음과 같은 과정으로 식사한다:

1. 왼쪽 젓가락부터 집어든다. 다른 철학자가 이미 왼쪽 젓가락을 쓰고 있다면 그가 내려놓을 때까지 생각하며 대기한다.

2. 왼쪽을 들었으면 오른쪽 젓가락을 든다. 들 수 없다면 1번과 마찬가지로 들 수 있을 때까지 생각하며 대기한다.

3. 두 젓가락을 모두 들었다면 일정 시간동안 식사를 한다.

4. 식사를 마쳤으면 오른쪽 젓가락을 내려놓고, 그 다음 왼쪽 젓가락을 내려놓는다.

5. 다시 생각하다가 배고프면 1번으로 돌아간다.

이는 교착상태의 대표적인 예제로, 위에서 언급한 4가지 필요조건을 모두 만족한다. 교착상태가 발생하면 starvation이 일어난다.

교착상태는 4가지 조건 중 하나의 조건만 어겨도 벗어날 수 있다.
