---
layout: post
title: 2023-2 GDSC BE mount
date: 2023-09-10 19:10 +0900
categories: [GDSC]
tags: [gdsc yonsei, backend]
render_with_liquid: false
---

해당 포스트는 2023-2 GDSC Yonsei BE 파트 mount 과정 이론 관련 학습 내용이다.

## VM과 컨테이너의 차이

![vm docker 차이](/assets/img/posts/vm_docker.png){: w="700" h="400" }
_출처 : https://cwal.tistory.com/66_

### VM (Virtual Machine)

하나의 물리적인 컴퓨터 위에 하이퍼바이저가 존재하여 하드웨어 자원을 가상화한 레이어를 제공한다. 각각의 VM은 서로간의 존재를 알 수 없으며 커널을 포함한 OS는 독립적으로 실행된다.

물리적인 컴퓨터와 기능면에서 차이가 없으므로 다양한 작업을 할 수 있지만 VM마다 자체 OS를 가지고 있으므로 무겁다.

### Container

컨테이너는 Host 측에서 봤을 때 다른 프로세스와 다를 것이 없다. 실행에 필요한 라이브러리, 파일, 환경변수 등을 담고 있는 Image로부터 생성되며 마이크로서비스 단위로 구성된다.

하나의 Host안에 존재하는 모든 컨테이너는 동일한 커널을 공유한다는데서 VM과 큰 차이가 있으며 하이퍼바이저나 Guest OS가 존재하지 않으므로 가볍고 빠른 편이다.

## 토큰 기반 인증 / 세션 기반 인증

아래 내용은 [hudi.blog](https://hudi.blog/session-based-auth-vs-token-based-auth/)를 참고하였다.

**인증(Authentication)**이란 클라이언트가 자기자신이라고 주장하고 있는 사용자가 맞는지를 검증하는 과정이다. 쉽게 말하자면 로그인이다. HTTP는 비상태성이라는 특징을 가지므로 사용자 인증에 대한 정보를 기억하지 못한다. 매번 인증 요청을 보낼 수 없기 때문에 서버는 **세션**과 **토큰**이라는 방식으로 사용자를 인가한다.

### 세션 기반 인증

세션기반 인증은 사용자의 인증 정보가 서버의 세션 저장소에 저장되는 방식이다. 사용자가 로그인을 하면, 해당 인증 정보를 서버의 세션 저장소에 저장하고, 사용자에게는 저장된 세션 정보의 식별자인 Session ID를 발급한다. 발급된 ID는 브라우저에 쿠키 형태로 저장되지만, 실제 인증 정보는 서버에 저장되어 있다.

브라우저는 인증 이후의 요청마다 HTTP 쿠키 헤더에 Session ID를 함께 서버로 전송하여 인증받는다.

### 토큰 기반 인증

토큰 기반 인증은 인증 정보를 클라이언트가 직접 들고 있는 방식이다. 인증 정보는 토큰의 형태로 브라우저의 로컬 스토리지 혹은 쿠키에 저장된다. 대표적인 토큰인 JWT의 경우 디지털 서명이 존재해 토큰의 내용이 위변조 되었는지 서버측에서 확인할 수 있다.

사용자가 가지고 있는 토큰을 HTTP Authorization 헤더에 실어 보낸다.

세션의 경우 트래픽이 적고 서버에서 관리하므로 보안성이 높은 장점이 있다. 하지만 여러대의 서버가 요청을 처리하는 수평 확장 시 세션 불일치 등의 문제가 발생하며 이를 해결하기 위해 추가적인 작업 필요하다. 또한 세션 데이터를 서버가 들고있어야 하므로 사용자가 많을 경우 서버의 부담이 커진다. 따라서 사용자가 많은 웹 애플리케이션을 운영할 때라면 토큰 기반 인증 방식을 사용하는 것이 좋을 것 같다.

## 동기/비동기 & 블로킹/논블로킹

해당 파트는 [Inpa Dev 블로그 포스트](https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%EB%8F%99%EA%B8%B0%EB%B9%84%EB%8F%99%EA%B8%B0-%EB%B8%94%EB%A1%9C%ED%82%B9%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC)를 참고하였다.

동기/비동기는 요청한 작업에 대한 완료 여부를 신경 써서 작업을 순차적으로 수행할지에 대한 관점이며, 블로킹/논블로킹은 현재 작업이 차단되느냐 아니냐에 따라 다른 작업을 수행할 수 있는지에 대한 관점이다.

### 동기(Synchronous) / 비동기(Asynchronous)

![sync async](/assets/img/posts/sync_async.png){: w="700" h="400" }
_출처 : https://medium.com/from-the-scratch/wtf-is-synchronous-and-asynchronous-1a75afd039df_

그림과 같이 요청한 작업에 대해 완료 여부를 따져 순차적으로 처리하는 것을 동기라고 하고, 그렇지 않은 것을 비동기라고 한다. 비동기를 사용할 경우 요청한 작업에 대하여 완료 여부를 신경쓰지 않고 그 다음 작업을 수행하므로 멀티 작업을 진행할 수 있어 성능상의 이점이 있다.

동기의 예시로 각 언어의 input관련 함수 등이 있으며, 비동기의 예시로 JS의 setTimemout()등이 있다. 각 함수의 실행을 보면 동기와 비동기의 작동 방식에 대하여 알 수 있다.

### 블로킹(Blocking) / 논블로킹(Non-Blocking)

![blocking non-blocking](/assets/img/posts/blocking_non-blocking.png){: w="700" h="400" }
_출처 : https://www.researchgate.net_

블로킹은 다른 요청의 작업을 처리하기 위해 현재 작업을 block하는 것이고, non-blocking은 block 하지 않는 것이다. 동기/비동기가 전체적인 작업에 대한 순차적인 흐름에 대한 것이라면, 블로킹/논블로킹은 전체적인 작업의 흐름 자체를 막냐 안 막냐로 볼 수 있다.

## ORM (Object Relational Mapping)

객체와 관계형 데이터베이스의 데이터를 자동으로 매핑해주는 것을 말한다. 객체 모델과 관계형 모델 간의 불일치를 자동으로 SQL을 생성하여 해결해준다. 객체를 통해 간접적으로 데이터베이스 데이터를 다룰 수 있다.

### ORM의 장점

- 객체 지향적인 코드로 더 직관적이고 비즈니스 로직에 더 집중할 수 있게 도와준다.
- 유지보수의 편리성이 증가한다.
- DBMS에 대한 종속성이 줄어든다.

### ORM의 단점

- 완벽한 ORM으로만 서비스를 구현하기 힘들다.

## RDBMS / NoSQL

해당 파트는 본 블로그 [NewSQL 포스트](https://hobbychive.github.io/posts/newsql/)를 참고하면 된다.

## Index

데이터베이스에서 SELECT, UPDATE, DELETE등의 연산을 할 때 대상 데이터를 찾기 위해 scan을 해야 한다. 이 때, 모든 데이터를 scan 하는 것은 cost가 높기 때문에 데이터와 데이터의 위치를 포함한 자료구조를 생성하여 빠르게 조회할 수 있도록 해주는 것이 **인덱스**이다.

### 인덱스의 장점

인덱스를 활용하면 테이블을 조회하는 속도와 그에 따른 성능을 향상시킬 수 있다는 장점이 있다. 또한 전반적인 시스템의 부하를 줄일 수 있다.

### 인덱스의 단점

인덱스를 관리하기 위해서는 추가적인 저장공간이 필요하다. 또한 INSERT, DELETE, UPDATE를 할 때마다 인덱스를 관리하기 위한 추가 작업을 해주어야 하는 오버헤드가 발생한다. 앞서 언급한 연산이 빈번한 속성에 인덱스를 걸게된다면 오히려 성능이 저하될 수 있다.

따라서 규모가 작지 않은 테이블에 INSERT, UPDATE, DELETE가 자주 발생하지 않으면서 JOIN, WHERE, ORDER BY등 조회가 빈번한 컬럼에 인덱스를 활용하면 성능 향상을 기대할 수 있다.

## Transaction, ACID, Lock

트랜잭션이란 DBMS에서 최소한의 작업 단위이다. 여러사람이 데이터베이스를 동시에 사용하더라도 데이터에 문제가 없어야 하며, 이것에 대한 특성이 ACID이다.

### ACID

- 원자성(Atomicity) : 하나의 트랜잭션에 해당하는 연산이 모두 정상적으로 처리되거나 모두 처리되지 않아야 한다는 all-or-nothing 원칙
- 일관성(Consistency) : 데이터베이스의 데이터는 일관된 상태를 유지해야 하며, 트랜잭션의 결과가 제약조건을 해치면 안된다
- 격리성(Isolation) : 각각의 트랜잭션은 독립적으로 수행되어야 한다
- 지속성(Durability) : 한 번 커밋된 내용은 영구적으로 보존되어야 한다

위 원칙을 지키지 위해 각 트랜잭션에서 데이터에 접근할 때 lock을 걸어주게 된다. 데이터를 읽을때와 쓸때의 lock이 각각 존재하며, 여러 트랜잭션이 공유하고 있는 데이터에 동시에 접근할 수 없도록 하는 2 phase locking 프로토콜을 사용한다.

## 동시성과 병렬성

**동시성**이란 하나의 시스템이 여러 작업을 동시에 처리하는 것처럼 보이게 하는 것이다. 실질적으로는 한번에 하나의 작업만을 처리하며, 여러개의 스레드를 생성하여 하나의 작업을 분할하여 처리하거나 비동기적으로 여러개의 작업을 처리하는 것을 말한다.

**병렬성**이란 여러 작업을 실제로 동시에 처리하는 것이다. 멀티코어 프로세서에서 각 코어별로 별도의 프로세스를 생성하여 동시에 실행이 가능하다.

병렬성과 동시성은 비슷해 보이지만 완전히 다르다고 볼 수 있다. 동시성은 다른 작업들이 서로 영향을 주면서 동시에 실행되는 것처럼 보이는 것에 반해 병렬성은 각각의 작업들이 독립적으로 실행된다. 즉 동시성은 논리적인 개념이고, 병렬성은 물리적인 개념이라 할 수 있다.

## 테스트 코드

해당 부분은 [요즘IT의 아티클](https://yozm.wishket.com/magazine/detail/1964/)을 참고하였다.
테스트 코드는 소프트웨어의 기능과 동작을 테스트하는 코드이다. 단계별로 테스트 대상이 다르며, 시스템 개발 과정을 시각화한 V모델에서 각 단계의 테스트는 무엇인지 확인할 수 있다.

![V model](/assets/img/posts/v_model.png){: w="700" h="400" }
_출처 : https://www.geeksforgeeks.org/software-engineering-sdlc-v-model/_

### Unit test

단위 테스트(Unit Test)는 개별적인 코드 단위(함수, 메소드 등)가 제대로 작동하는지를 알아보는 테스트이다. 테스트 케이스를 작성하여 각각의 코드 단위가 정확한 입력값과 출력값을 반환하는지 확인한다.

### Integration Test

통합 테스트(Integration Test)는 서로 다른 모듈들 간의 상호작용을 확인하는 테스트이다. 보통 모듈 간 인터페이스 테스트, 시스템 레벨 테스트 등의 방법으로 수행되며, 둘 이상의 모듈을 거쳐서 동작하는 API 테스트 시나리오를 기반으로 통합 테스트를 수행한다.

## CI/CD

### CI (Continuous Integration)

CI란 **지속적 통합**으로, 여러명이 하나의 코드에 대해 수정을 진행해도 지속적으로 통합하며 관리할 수 있음을 의미한다. 개발을 끝마치고 전체 서비스가 배포되지 않아도 각 기능이 추가/수정될 때마다 올바르게 동작하는지를 검증하며 코드 품질을 관리해야한다. 개발자가 직접 코드를 병합하고 빌드, 테스트를 검증하는 것은 시간이 많이 소요되므로, 이를 자동화하여 수정한 코드가 브랜치에 병합될 때 자동으로 테스트되게 하면 시간을 단축할 수 있다.

### CD (Continuous Deployment)

CD란 **지속적 배포**를 의미한다. CI를 통해 새로운 기능의 빌드와 테스트 병합까지 완료되었다면 빌드와 테스트를 거쳐 저장소에 업로드를 하게 된다. 이 병합된 내역을 저장소 뿐만 아니라 사용자가 사용할 수 있는 배포환경까지 릴리즈하는 것이 바로 지속적 배포이다.

## TCP/UDP

[OSI 7 계층에 대한 포스트](https://hobbychive.github.io/posts/gdsc-2-network/) 참고

## www.naver.com을 주소창에 입력했을 때 네트워크 관점에서 일어나는 일

1. 주소창에 www.naver.com을 입력한다.
2. 브라우저가 캐시에서 DNS 기록이 있는지 확인한다.
   - 총 4가지 캐시를 확인한다 - 브라우저, OS, 라우터, ISP
3. DNS 기록이 없다면 IP주소를 찾기 위해 DNS 쿼리를 날린다.
   - 상위 DNS 서버로 이동하며 해당 IP주소가 있는지 찾는다.
   - 찾았다면 해당 주소를 전달받는다.
4. 브라우저가 해당 서버와 TCP 연결을 한다.
   - 3-way handshake 과정을 거친 후 TCP connection이 생성된다.
5. 브라우저가 웹 서버에 HTTP 요청을 보낸다.
6. 서버가 해당 요청을 받고 응답을 보낸다.
   - 해당 응답에는 첫 화면을 띄우기 위한 html, css, js 파일 등이 들어있다.
7. 브라우저가 해당 파일들을 렌더링한다.

## 네트워크 관련 공격 기법

### SQL Injection

SQL Injection은 임이의 SQL문을 주입하고 실행되게 하여 데이터베이스가 비정상적인 동작을 하도록 조작하는 공격 방식이다. 공격의 쉬운 난이도에 비해 피해가 상당하다.

### XSS (Cross Site Scripting)

게시판이나 웹 메일 등에 자바스크립트와 같은 스크립트 코드를 삽입하여 개발자가 고려하지 않은 기능이 작동하게 하는 공격 방식이다. XSS에 취약한 페이지 및 게시판에 공격을 수행함으로써 해당 페이지를 이용하는 사용자의 쿠키 정보나 세션 ID 등을 획득할 수 있다.

### CSRF (Cross Site Request Forgery)

인터넷 사용자가 자신의 의지와는 무관하게 공격자가 의도한 행위를 특정 웹사이트에 요청하게 만드는 공격이다. 위조 요청을 전송하는 서비스에 희생자가 로그인 상태이며, 해커가 만든 피싱 사이트에 접속했을 때 피싱 사이트에 어떠한 동작을 수행하는 코드를 감추어놓고 위조 요청을 전송하게 된다.

## 클라우드 컴퓨팅

클라우드 컴퓨팅이란 컴퓨팅 리소스를 인터넷을 통해 서비스로 사용할 수 있는 주문형 서비스이다. 기업에서 직접 리소스를 조달하거나 구성, 관리할 필요가 없으며, 사용한 만큼 요금을 지불하면 된다. 대표적인 서비스로 **GCP, AWS, NCP** 등이 있다.

### GCP, AWS, NCP 비교

GCP (Google Cloud Platform) / AWS (Amazon Web Service) / NCP (Naver Cloud Platform)

1. 규모 및 지역

AWS와 GCP는 전 세계적으로 광범위하게 사용되고 있다. 반면 NCP는 한국 내에서 사용된다.

2. 가격 정책

AWS는 시작 비용이 낮아 초보자가 사용하기 쉽다. GCP는 자체 네트워크를 보유하고 있으며 데이터 전송 비용이 저렴하다. NCP는 로컬 마켓에서 앞선 두 서비스보다 비교적 저렴한 가격으로 서비스를 제공한다.

3. 기술 지원

AWS는 서드파티 도구 및 플랫폼 통합에서 강점을 보인다. GCP는 인공지능 및 머신러닝 분야에서 강점이 있다. NCP는 한국어 문서 및 24시간 기술 지원을 제공한다.

## 캐시 메모리, 캐시 지역성

해당 부분은 [첼씨 블로그 포스트](https://chelseashin.tistory.com/43)를 참고하였다.

### 캐시 메모리 (Cache Memory)

캐시 메모리란 주기억장치에서 사용하는 프로그램과 데이터를 저장해주어 속도를 빠르게 하는 메모리이다. 주기억장치와 CPU 사이에 위치하며, 거의 CPU의 속도와 비슷할 정도의 속도를 가지고 있다. 캐시 메모리를 사용하면 주기억장치를 접근하는 횟수가 줄어들어 컴퓨터의 처리속도가 향상되며, 크기는 보통 수십 KByte에서 수백 KByte이다.

### 캐시 지역성 (Cache Locality)

캐시가 효율적으로 동작하려면 Hit rate를 극대화 시켜야 한다. 이를 위해서는, 캐시에 저장할 데이터가 **지역성**을 가져야 한다. 여기서의 지역성이란, 데이터 접근이 시간적, 혹은 공간적으로 가깝게 일어나는 것을 의미한다.

지역성의 종류에는 시간적 지역성, 공간적 지역성이 있으며 시간적 지역성은 특정 데이터에 접근했을 때 가까운 미래에 접근할 가능성이 높은 것을 의미하며 공간적 지역성은 특정 데이터와 주소상으로 가까운 곳에 위치한 것을 의미한다.
